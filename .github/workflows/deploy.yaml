name: Deploy to VPS
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to VPS
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          script: |
            # Set project variables
            export PROJECT_NAME="enfyra-cms"
            export APP_DIR="/apps/$PROJECT_NAME"
            export DEPLOYMENT_DIR="/deployments/$PROJECT_NAME"
            
            # Update source code
            cd $APP_DIR
            git reset --hard HEAD
            git clean -fd
            git pull origin main
            export IMAGE_TAG=$(git rev-parse --short HEAD)
            
            # Build with timeout and retry
            echo "Building Docker image $PROJECT_NAME:$IMAGE_TAG..."
            if ! timeout 600 docker build -t $PROJECT_NAME:$IMAGE_TAG . ; then
              echo "Build failed or timed out, retrying..."
              docker system prune -f || true
              timeout 600 docker build -t $PROJECT_NAME:$IMAGE_TAG . || exit 1
            fi
            
            # Verify build success
            if ! docker images $PROJECT_NAME:$IMAGE_TAG | grep -q $IMAGE_TAG; then
              echo "ERROR: Docker image build failed!"
              exit 1
            fi
            
            echo "Build completed successfully"
            
            # Detect K8s mode early
            export K8S_MODE=$(yq ".kubernetes.provider" ~/configs/$PROJECT_NAME.yaml 2>/dev/null || echo "microk8s")
            echo "K8S_MODE detected: $K8S_MODE"
            
            # Configure image for MicroK8s
            if [ "$K8S_MODE" = "microk8s" ]; then
              echo "=== Configuring image for MicroK8s ==="
              
              # Check if we can use microk8s docker directly
              if microk8s status --addon registry 2>/dev/null | grep -q "enabled"; then
                echo "Using MicroK8s registry..."
                # Tag for local registry
                docker tag $PROJECT_NAME:$IMAGE_TAG localhost:32000/$PROJECT_NAME:$IMAGE_TAG
                docker push localhost:32000/$PROJECT_NAME:$IMAGE_TAG
                # Update Pulumi to use registry image
                export PULUMI_IMAGE="localhost:32000/$PROJECT_NAME:$IMAGE_TAG"
                echo "Using registry image: $PULUMI_IMAGE"
              else
                echo "Using local Docker daemon approach..."
                # Use containerd namespace directly - much faster
                docker tag $PROJECT_NAME:$IMAGE_TAG $PROJECT_NAME:$IMAGE_TAG
                # Import only if not exists
                if ! microk8s ctr images list | grep -q "$PROJECT_NAME:$IMAGE_TAG"; then
                  echo "Quick import via pipe..."
                  docker save $PROJECT_NAME:$IMAGE_TAG | microk8s ctr image import -
                else
                  echo "Image already exists in MicroK8s"
                fi
                export PULUMI_IMAGE="$PROJECT_NAME:$IMAGE_TAG"
              fi
              
              echo "=== Image configuration completed ==="
            fi

            # Setup Kubernetes config
            cd $DEPLOYMENT_DIR

            if [ "$K8S_MODE" = "microk8s" ]; then
              echo "Using MicroK8s configuration"
              export KUBECONFIG=/var/snap/microk8s/current/credentials/client.config
            else
              echo "Using kubeadm configuration"
              export KUBECONFIG=/etc/kubernetes/admin.conf
            fi

            # Setup Pulumi environment
            export PATH=$PATH:$HOME/.pulumi/bin
            export PULUMI_CONFIG_PASSPHRASE=''

            # Run Pulumi deployment with new image tag
            pulumi version
            pulumi login file://$(pwd)/.pulumi
            pulumi stack select $PROJECT_NAME
            
            # Clear any existing locks
            pulumi cancel || true
            
            pulumi config set image ${PULUMI_IMAGE:-$PROJECT_NAME:$IMAGE_TAG}
            pulumi up --yes

            # Cleanup old Docker images (keep latest 3)
            echo "=== Cleaning up old Docker images ==="
            echo "Current Docker images:"
            docker images $PROJECT_NAME --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}\t{{.Size}}" | grep -v REPOSITORY
            
            # Remove old Docker images except latest 3 
            echo "Removing old Docker images (keeping latest 3)..."
            docker images $PROJECT_NAME --format "{{.Repository}}:{{.Tag}}" | grep -v latest | tail -n +4 | xargs -r docker rmi -f || true
            
            # Remove ALL untagged images (dangling)
            echo "Removing all dangling/untagged images..."
            docker images -f "dangling=true" -q | xargs -r docker rmi -f || true
            
            # Cleanup old K8s images based on provider
            if [ "$K8S_MODE" = "microk8s" ]; then
              echo "Cleaning up old MicroK8s images..."
              # Keep only latest 2 project images
              microk8s ctr images list -q | grep "$PROJECT_NAME:" | grep -v latest | tail -n +3 | xargs -r microk8s ctr images remove || true
              # Basic containerd cleanup
              microk8s ctr content prune || true
            else
              echo "Cleaning up old kubeadm/containerd images..."
              crictl images | grep $PROJECT_NAME | grep -v '<none>' | sort -k4 -r | tail -n +4 | awk '{print $3}' | xargs -r crictl rmi || true
            fi
            
            # Show remaining images after cleanup
            echo "=== Remaining images after cleanup ==="
            if [ "$K8S_MODE" = "microk8s" ]; then
              echo "MicroK8s images:"
              microk8s ctr images list | grep $PROJECT_NAME || echo "No $PROJECT_NAME images found"
            else
              echo "Containerd images:"
              crictl images | grep $PROJECT_NAME || echo "No $PROJECT_NAME images found"
            fi
            
            echo "Docker images:"
            docker images $PROJECT_NAME --format "table {{.Repository}}:{{.Tag}}\\t{{.CreatedAt}}\\t{{.Size}}" || echo "No $PROJECT_NAME images found"
            
            # Aggressive Docker cleanup
            echo "=== Running comprehensive Docker cleanup ==="
            
            # Remove dangling images (not associated with any container)
            echo "Removing dangling images..."
            docker image prune -f || true
            
            # Remove unused build cache
            echo "Removing build cache..."
            timeout 60 docker builder prune -f || echo "Build cache cleanup completed or timed out"
            
            # Remove stopped containers
            echo "Removing stopped containers..."
            docker container prune -f || true
            
            # Remove unused networks
            echo "Removing unused networks..."
            docker network prune -f || true
            
            # Remove unused volumes
            echo "Removing unused volumes..."
            docker volume prune -f || true
            
            # Clean up container logs (truncate large logs)
            echo "Cleaning up container logs..."
            find /var/lib/docker/containers/ -name "*.log" -exec truncate -s 0 {} \; 2>/dev/null || true
            
            # Final system prune (everything unused)
            echo "Final system cleanup..."
            timeout 120 docker system prune -af --volumes || echo "System prune completed or timed out"
            
            # Show final disk usage
            echo "=== Final disk usage ==="
            timeout 30 df -h / || echo "Disk usage check timed out"
            echo "=== Docker directory usage ==="
            timeout 30 du -sh /var/lib/docker/* 2>/dev/null | sort -rh | head -10 || echo "Docker directory check completed or timed out"
            echo "=== Docker system df ==="
            timeout 30 docker system df || echo "Docker system df completed or timed out"
            echo "=== Total Docker images ==="
            timeout 30 docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}" | head -20 || echo "Docker images list completed or timed out"
            
            echo "=== Cleanup completed - deployment will continue ==="
            
            # Final cleanup of temp files
            echo "Cleaning up temporary files..."
            rm -f /tmp/$PROJECT_NAME-*.tar 2>/dev/null || true
            rm -f /tmp/enfyra-*.tar 2>/dev/null || true
            echo "Temp files cleaned"

  # Call cleanup workflow after successful deployment
  cleanup:
    needs: deploy
    uses: ./.github/workflows/cleanup.yaml
